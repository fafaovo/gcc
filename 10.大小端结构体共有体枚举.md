### 大小端
    + 假设 int a = 0x11223344  11是高字节  44是低字节
    + 大端序 ： 在内存中存储的是 高 44 33 22 11低 
    + 小端序 ： 在内存中存储的是 高 11 22 33 44低
    + 大端:数据的高字节存放在低地址,低字节存放高地址
    + 小端:数据的高字节存放到高地址,低字节存放低地址


### 主函数传参
    + int main(int argc,char **argv) argc参数的个数 argv参数
    + int main(int argc,char *argv[])
    + 参数的个数会把程序名也当成是参数,在参数中默认当为字符串
    + 使用：糖果传递参数,让主函数运行的时候可以接受外界的参数

### 结构体 [复合数据类型]
    * 结构体类型 结构体变量 结构体指针
    * 没有名字的结构体叫匿名结构体
    * 初始化以及赋值
        + .直接成员运算符
        + ->间接成员运算符
    * linux操作系统内核源码写法
    stu s1 = {  
		.score = 56,  
		.age = 15,  
		.name = "李四"   //定义立马初始化是可以使用等于号的
	};  
    //可以不按照顺序也可以部分初始化

    * 同种类型的结构体变量之间是可以用 = 直接赋值的
    * 结构体求大小 [内存对齐]
        + 结构体的大小要满足字节对齐
        + 在32位按照四个字节对齐 在64位按照八个字节对齐
        + 计算规则
        + 在64位下
        + 找到结构体中数据类型最大的成员,最大成员 >= 8个字节, 那么整个结构体按照8个字节对齐,最大成员<8 字节 整个结构体按照最大成员大小对齐
            * [数组的类型是char类型]
        + 按照n字节对齐,结构体最终大小能够被能n整除
        + 类型最大成员 >= 8字节，整个结构体按照8字节对齐.此时所有小于8字节的成员类型，挨在一起需要合并
        + 类型最大成员 < 8字节，所有小于最大成员的成员类型，挨在一起的需要合并

### 位域
    + 使程序员可以人为指定某个结构体变量占用多少位

### 联合体union
    + 联合体所有的成员公用同一块内存空间,联合体的大小由最大的成员大小来决定,也要满足字节对齐
    + 用来标识互斥的变量

### 枚举euum
    + 枚举值没有人为赋值,默认从0开始
    + 枚举值人为赋值,枚举值从赋值的位置开始往后递增

### scanf
    + scanf的返回值是读到符合要求的字符个数

### printf
    + 同一个变量在printf中 类似于逗号表达式，从左到右全部算完结果然后才打印
        + int b = 99;
        + printf("%d%d%d%d",b,b+10,b-=5,b+=45);
        + 输出的是 149 149 149 149
    + 其实思路就是个栈，从左到右进栈,接着挨个出栈

### 字符串
    * char buf[20] = "hello world" 只能定义的时候给字符串
    + 或者strcpy(buf,"hello world")拷贝
    + 或者一个一个字符丢进去
    + 不能在定义后再去赋值字符串