### int 类型的数组
    * []内不写元素个数,但是定义数组后立马得初始化
        * int a[]; a[0] = 78 这种写法是错的
    * a[10] 里面还是随机数 
    * a[10] = {1} 第一位是1，其他都是0
    * 数组越界的危害
        * 1.往前越界: a[-2] 
        * 2.往后越界: a[999]
    * 容易发生段错误 segment fault
    * [由于程序员在代码中访问非法地址导致的]
    * 数组的存储
        * 数组在计算机中是连续存储的(数组元素的地址是挨在一起的)
### char 类型的数组
    * 数组的大小
        + 字符串在计算机的存储方式
            + 字符串默认有一个结束标记\0 (ASCII:0)
            + 编译器自动加的,不需要程序员操心
        + sizeof 是包括\0的
        + strlen 是不包括\0的
            + strlen求长度是遇到\0才会结束


    * 在liunx系统下支持arr[a]  ->变长数组     
    * 空字符串
        + char buf[10] = ""
            + 空字符串 strlen -> 0
    * 'A' 和 “A” 的区别
        + 'A' 字符A
        + "A" A\0 字符串A
    * 清空数组
        bzero(void *s,size_t n);

### 32位系统
    * 内存地址长度是32位


### 数组
    * a[2] 等价于 *(a+2)
    * int a[10] = { 0 } 部分初始化,将第0位初始化为0,其他部分也会被初始化成0


### 数组的怪异写法
    * int buf[0] 等价于 int 0[buf]


### 二维数组
    * int a[5][5] 行列存放整数 [行可以不写，但是必须立马初始化]
    * char b[5][10] 用来保存多个字符串
    * 二维数组的分组初始化
        * 分组初始化->花括号的嵌套
        * 语法要求：分组初始化，里面的花括号必须从左到右连续使用
            + int arr6[5][6] = { { 5 }, { 8, 9 }, 89, { 63 } }; 这个写法最后的{63} 在win下会被删掉花括号，而在linux下会报错
    * 二维数组的大小
        + 1.两个下标都有 行*列*sizeof(类型)
        + 2.少了行下标 依据初始化列表中值的个数,确定有几行
    * 字符串在一维数组和二维数组中如何存储,如何比较
        + 复制拷贝字符串
            + strcpy(s1,s2)将s2拷贝到s1里
            + strncpy(s1,s2,n)拷贝n个字符
        + 字符串比较
            + strcmp(s1,s2)比较
                + s1大于s2 返回 > 0
                + s1小于s2 返回 < 0
                + s1等于s2 返回 0
            + strncmp(s1,s2,n)比较n个字符
        + 字符串追加
            + strcat(s1,s2)追加
                + 将s2追加到s1后面
            + strncat(s1,s2,n)追加s2中n个字符
            

