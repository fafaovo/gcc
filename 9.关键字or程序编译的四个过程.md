### 关键字

#### static 
+ 1.修饰全局变量和局部变量
    * 修饰全局变量
        * 改变全局变量的链接性,全局变量的链接性会从外部变量变成内部链接。链接性参考:[7.函数.md]
        * 此时这个全局变量就只能在定义他的.c中使用,其他.c文件不可使用
    * 修饰局部变量
        * 表示该局部变量只能初始化一次,修饰的局部变量是存放在数据段
+ 2.修饰函数
    * 普通函数具备外部链接性,static修饰的函数具备内壁链接性

#### coust
    * 1.修饰普通变量
        + const int a = 99; 表示a是个常量,常量是只读,但是不可修改,可以访问
    * 2.修饰指针
        + 如果const位于*的左侧,那么const就是用来修饰指针所指向变量的,即指针指向常量
            + int const *r = &n; *r不允许重新赋值
        + 如果const位于*的右侧，那么const就是修饰指针本身，即指针本身是常量
            + int * const r = &n; r为指针常量不允许重新赋值

#### extern
    * 1.声明外部的全局变量(非静态)
    * 2.声明外部的函数(非静态)

#### define 宏定义[预处理阶段就被处理掉了,也就是说没有入栈出栈的操作了]
    * 宏定义:字符的替换
    * 一般写成大写
        * 写法一: 普通的宏定义
            + #define PI 3.14
        * 写法二：带参数的宏定义  ( 宏函数) 
            + #define F(n) n*n
    * 特点：每个单独的宏定义都各自占一行,如果不在同一行必须加上续行符[续航符 \ ],并且宏定义的参数都是没有类型的,带参数的宏定义最好用圆括号括起来

#### typedef 类型重定义
    * 作用：
        + 给基本数据类型取别名
        + 给指针取取别名
            + typedef int* pint
        + 给函数指针取别名
            + typedef int (*funp)(int)   别名叫funp
            + funp p1 = add; add是个函数
        + 给数组取别名
            + typedef int a[10] 给int[10]这种类型取别名 别名为a
        + 给结构体取别名
    
    * 可移植数据类型


### auto register ·
    + auto 自动变量 加不加都一样
    + register 寄存器变量 访问速度快
    + volatile 修饰易变变量 告诉编译器这个变量会短时间会被改变很多次,不需要去优化变量


### 编译程序的四个过程
+ 1.一步到位 gcc hello.c -o hello 其实是经历了四个步骤
+ 2.四个过程
    + 1.预处理
        + 处理C程序中所有#开头的语句
            + 1.#include 
            + 2.#define
            + 3.条件编译
        + 把#开头的语句展开
            + gcc hello.c -o hello.i -E 
            + -E编译选项,用于对程序预处理
    + 2.编译
        + gcc hello.i -o hello.s -S
        + 把.i文件进一步编译成.s的汇编文件
    + 3.汇编（可重定位文件）
        + gcc hello.s -0 hello.o
        + 把.s文件生成.o文件[二进制]
    + 4.链接生成最终的可执行程序
        + gcc hello.o -o hello



### 内存分布 栈 堆 数据段 代码段


### 数据段 程序结束的时候才会释放
* 1. .bss段 未初始化的静态变量,未初始化的全局变量
* 2. .dat段 初始化的静态变量,初始化的全局变量
* 3. .rodat段 const修饰的常量

### 代码段
* 1. .text段   程序的代码  
* 2. .init段   启动代码