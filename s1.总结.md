### 数据类型中
    + 2^-1 等于 1/2^1
    + 求一个十进制的n进制,求无限除n,每次取余数,直到小于n,然后把得到的余数倒过来写
    + 一个八进制等于三个二进制位
    + 一个十六进制等于四个二进制位
    + 小数[详见1.数据类型.md]

### 格式输出符中
    + %n.m接类型 n是位宽[正数右边，负数左边] m是显示小数点几号位
        + n不写输出时表示不做限制

### 格式化IO函数中
    + prinft()遇到三种情况才会输出到屏幕
        + 1，\n
        + 2.return exit()
            + 在main函数中如果不写return，程序会自动生成一个
        + 3.缓冲区满了
    + printf的返回值是输出字符的个数 
    + _exit(0);  不刷新缓冲区，直接退出程序
    + scanf
        + 尽量不要加\n,也不要加空格

### 运算符
    + && 只要有一个为假,后续语句不执行
    + || 只要有一个为真,后续语句不执行
    + 位运算符
        * 位与 &    
            * 只要有一个为0,结果为0
            * 任何数跟0位与,结果都是0

        * 位或 |    
            * 只要有一个为1,,结果为1

        * 位取反 ~  
            * 0变成1,1变成0

        * 异或 ^    
            * 相同为0,相异为1
            * a ^ a = 0
            * a ^ 0 = a
        * 左移右移 << >>
            + << 左移运算符
                + 数据本身向高位移动，低位补0
                + 左移n位,相当于数据乘以2的n次方
            + >> 右移运算符
                + 算数右移 和 逻辑右移
                + 算数右移:数据本身向低位移动，高位补符号位
                    + 右移n位,相当于除以2的n次方
                + 逻辑右移:数据本身向低位移动，高位补0
                + 不同的操作系统采用的右移方式不同 [算数右移]
        * sizeof() 是个运算符.sizeof内表达式不执行任何语句
        * 逗号表达式 变量 = (表达式1,表达式2,表达式3...) 从左到右,最终结果是最右边的结果

### 循环
    * 在循环里面重复定义的变量,编译器只会帮你定义一次

### 条件判断
    * switch
        + case 语句后面只能是 整形常量 字符常量 枚举


### int 类型的数组
    * []内不写元素个数,但是定义数组后立马得初始化
        * 比如说 int a[]; a[0] = 78 这种写法是错的

### char 类型的数组
    * 在liunx系统下支持arr[a]  ->变长数组
    * 空字符串
        + char buf[10] = ""
            + 空字符串 strlen -> 0
    * 'A' 和 “A” 的区别
        + 'A' 字符A
        + "A" A\0 字符串A
    * 清空数组
        + bzero(void *s,size_t n);
        + 等同于数组初始化时 = { 0 };

### 数组
    * int a[10] = { 0 } 部分初始化,将第0位初始化为0,其他部分也会被初始化成0
    * 数组的怪异写法
        * int buf[0] 等价于 int 0[buf]

### 二维数组
    * int a[5][5] 行列存放整数 [行可以不写，但是必须立马初始化]
    * 语法要求：分组初始化，里面的花括号必须从左到右连续使用 
    * 字符串函数
        + 复制拷贝字符串 strcpy(s1,s2)将s2拷贝到s1里
        + 字符串比较 strcmp(s1,s2)比较
        + 字符串追加 strcat(s1,s2)将s2追加到s1后面

### 开辟堆空间
    * malloc 分配多少字节的堆空间
    * calloc 申请多少块内存区 , 申请内存区域的大小

### 指针
    * 解引用和取地址互为逆运算

### 指针的运算
    + 指针做加法加的是类型的大小
            + *p++ 先解引用p，然后p加1
            + (*p)++ 先解引用p，然后把解引用的值加一
            + *++p 现将++用于p,然后解引用
            + ++*p 先解引用,然后把结果+1
    + 两个指针相减算出来的是两个指针间隔了多少个(类型名)的数据
    即两个地址相减除以类型的大小(sizeof(类型名))
    + 指针减指针是算上最后一个元素的

### 指针和数组之间的坑
    + 双引号引起来的可以当指针,单引号的不行
        + char *q = 'h'; 错的，你再试图将一个指针指向了一个数字


    + printf(sizeof('a'));   --> stdin输出 4
        + C语言中字符常量默认是当成int类型
            + 常量，直接用的东西就是常量
        + C语言中小数默认当成double
        + C语言中字符串常量默认当成字符串首地址

    + 怪异写法
        + 用%c的方式打印"gec"[0] 等价于 0["gec"] 输出单个g
        + 甚至等价于 *("gec" + 0)

    + 数组当成函数的行参,sizeof是当成指针来求大小

### 函数
    + 局部变量会隐藏全局变量
    + 全局变量不初始化默认为0
    + 实参和形参技巧 行参 = 实参


### 函数指针 和 指针函数
    + 指向函数的指针
    + int add(int a,int b); int (*p)(int,int) = add;
    + 函数指针的另类写法
        + int (*p)(int,int) = &add;
        + (*p)(15,16);
        + 注意函数指针的写法很特殊,add和&add没啥区别
    * 指针函数 
    + 只要一个函数的返回值是指针,那么这个函数就叫指针函数


### 关键字 coust
    + 修饰指针
        + 如果const位于*的左侧,那么const就是用来修饰指针所指向变量的,即指针指向常量
            + int const *r = &n; *r不允许重新赋值
        + 如果const位于*的右侧，那么const就是修饰指针本身，即指针本身是常量
            + int * const r = &n; r为指针常量不允许重新赋值


#### define 宏定义[预处理阶段就被处理掉了,也就是说没有入栈出栈的操作了]
    + 宏定义:字符的替换
    + 一般写成大写
    + 特点：每个单独的宏定义都各自占一行,如果不在同一行必须加上续行符[续航符 \ ],并且宏定义的参数都是没有类型的,带参数的宏定义最好用圆括号括起来


#### typedef 类型重定义
    + 给函数指针取别名
        + typedef int (*funp)(int)   别名叫funp
        + funp p1 = add; add是个函数


### 编译程序的四个过程 内存分布 栈 堆 数据段 代码段
    + 参考 [9.关键字or程序编译的四个过程]


### 大小端
    + 大端:数据的高字节存放在低地址,低字节存放高地址
    + 小端:数据的高字节存放到高地址,低字节存放低地址

### 结构体 [复合数据类型]
    * linux操作系统内核源码写法
    stu s1 = {  
		.score = 56,  
		.age = 15,  
		.name = "李四"   //定义立马初始化是可以使用等于号的
	}; 


### scanf
    + scanf的返回值是读到符合要求的字符个数

### printf
    + 同一个变量在printf中 类似于逗号表达式，从左到右全部算完结果然后才打印
        + int b = 99;
        + printf("%d%d%d%d",b,b+10,b-=5,b+=45);
        + 输出的是 149 149 149 149
    + 其实思路就是个栈，从左到右进栈,接着挨个出栈

### 字符串
    * char buf[20] = "hello world" 只能定义的时候给字符串
    + 或者strcpy(buf,"hello world")拷贝
    + 或者一个一个字符丢进去
    + 不能在定义后再去赋值字符串


### 宏定义
        + #ifdef 宏定义  判断宏定义是否定义了
        + #ifndef 宏定义  判断宏定义是不是没有定义



### 复习要点
    * 数据存储方式 %m.n中m和n代表什么
    * scanf的返回值和死循环
    * 除法运算结果,位运算 [某一位二进制置0置1]
    * 逻辑与和逻辑或只要有一个符合逻辑后续不会执行,逻辑与优先级高
    * sizeof是运算符,和strlen的区别(sizeof算\0),并且当中表达式不执行,数组当行参都是当指针
    * 数组和指针的关系,奇怪的写法,char类型的字符串只能在定义的时候赋值字符串
    * 二维数组分组初始化 里面的花括号必须从左到右连续使用 
    * 指针的运算
    * 制作访问数组 &和*挨在一起可以消除 
    * const关键字 
    * 内联会展开,没有函数入栈出栈的过程
    * typedef 和 宏定义的区别
    * #if #ifdef #ifndef 的区别
    * 内存布局